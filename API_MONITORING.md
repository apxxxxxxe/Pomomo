# Discord APIレスポンスヘッダ監視機能

## 概要

この機能は、Discord APIへのリクエスト（特にメッセージ編集）のレスポンスヘッダを監視し、レート制限情報を記録・分析する機能です。429エラー（Rate Limit Exceeded）の原因を特定し、適切な更新頻度を決定するために使用できます。

**✅ 実装完了**: aiohttpレベルでのフックにより、実際のDiscord APIレスポンスヘッダの取得に成功しています。

## 機能

### 1. 二重レベルの監視システム

#### aiohttpレベルのフック
- **実際のHTTPレスポンスヘッダを取得**
- Discord APIからのレート制限ヘッダ（`X-RateLimit-*`）をリアルタイムで記録
- 低レベルでの包括的な監視

#### アプリケーションレベルの手動ログ
- メッセージ編集の実行時間を精密測定
- 編集操作の成功/失敗を詳細記録
- 操作タイプ別の分類（pomodoro, countdown, classwork）

### 2. レート制限の詳細情報

取得される重要な情報：
- **制限値**: 5リクエスト/秒（メッセージ編集エンドポイント）
- **残り回数**: リアルタイムでの利用可能回数
- **リセット時間**: 制限がリセットされる正確な時刻
- **バケット識別子**: レート制限の管理単位

### 3. 高度な分析ツール
- ログデータの統計分析
- レート制限エラーパターンの特定
- 最適な更新頻度の推奨値算出
- 実際のレート制限値に基づく安全マージンの計算

## 設定と使用方法

### 1. 自動セットアップ

機能は自動的に有効になります。ボット起動時に以下のログが出力されます：

```
INFO - API monitoring setup completed
INFO - aiohttp level monitoring enabled
```

成功した場合、aiohttpレベルでの実際のAPIヘッダ取得が有効になります。

### 2. ログファイルの確認

APIヘッダ情報は以下のファイルに記録されます：

```
logs/api_headers.jsonl
```

ファイル形式はJSON Lines（1行に1つのJSONオブジェクト）です。

**ログローテーション機能**:
- ファイルサイズが10MBに達すると自動的にローテーション
- 7個のバックアップファイルを保持（api_headers.1.jsonl, api_headers.2.jsonl, ...）
- 最も古いバックアップファイルは自動削除

**本番運用モード**:
- デフォルトでは成功時（200 OK）のログは記録されません
- エラー時（429, 500など）および警告時（残り制限回数 < 5）のみ記録
- デバッグ時は環境変数 `API_DEBUG_LOG_ALL_RESPONSES=true` で全レスポンス記録

### 3. ログ分析の実行

分析スクリプトを使用してログを分析できます：

```bash
cd bot
python analyze_api_logs.py
```

**自動的に全てのローテーションされたファイルを読み込みます**（api_headers.jsonl, api_headers.1.jsonl, api_headers.2.jsonl, ...）

特定のログファイルを指定する場合：

```bash
python analyze_api_logs.py /path/to/api_headers.jsonl
```

JSON形式で結果を出力する場合：

```bash
python analyze_api_logs.py --json
```

## ログデータ形式

### 2種類のログエントリ

#### aiohttpフック経由（実際のAPIヘッダ）

```json
{
  "timestamp": 1763145146.151625,
  "iso_timestamp": "2025-11-15 03:32:26",
  "method": "PATCH",
  "url": "https://discord.com/api/v10/channels/1425535963177684993/messages/1438959551679303780",
  "status_code": 200,
  "rate_limit": {
    "x-ratelimit-bucket": "3df15bae86f6647dd4dfcbd5c6949480",
    "x-ratelimit-limit": "5",
    "x-ratelimit-remaining": "4",
    "x-ratelimit-reset": "1763145146.723",
    "x-ratelimit-reset-after": "1.000"
  },
  "aiohttp_hook": true
}
```

#### 手動ログ（アプリケーションレベル）

```json
{
  "timestamp": 1763145146.1518853,
  "iso_timestamp": "2025-11-15 03:32:26",
  "method": "PATCH",
  "url": "discord_message_edit",
  "status_code": 200,
  "operation_type": "pomodoro_message_edit",
  "duration_ms": 333.67,
  "success": true,
  "error": null,
  "manual_log": true
}
```

### 実際のDiscord APIレート制限ヘッダの説明

| ヘッダ | 実際の値例 | 説明 |
|-------|----------|------|
| `x-ratelimit-limit` | `"5"` | **メッセージ編集エンドポイントの制限: 5回/秒** |
| `x-ratelimit-remaining` | `"4"` | 現在のバケットでの残り回数 |
| `x-ratelimit-reset` | `"1763145146.723"` | リセット時刻（Unix timestamp） |
| `x-ratelimit-reset-after` | `"1.000"` | リセットまでの秒数（通常1秒） |
| `x-ratelimit-bucket` | `"3df15bae86f6647dd4dfcbd5c6949480"` | バケット識別子（チャンネル＋メッセージ単位） |

### 重要な発見

**メッセージ編集の厳格な制限**:
- 制限: **5リクエスト/秒**
- リセット間隔: **1秒**
- 現在の実装（約5秒間隔）は**安全圏内**
- より頻繁な更新（1-2秒間隔）は危険

## 分析レポートの読み方

### 実際のプロジェクト分析結果

```
📊 基本統計:
  総メッセージ編集リクエスト数: 46
  レート制限エラー(429)回数: 0
  低残り回数警告: 0

📈 ステータスコード分布:
  200: 46回 (100.0%)

⏱️ 更新間隔統計（秒）:
  最短: 4.156
  最長: 47.621
  平均: 10.165
  中央値: 5.279

💡 推奨事項:
  ✅ レート制限エラーは発生していません
```

**分析結果の解釈**:
- **429エラー: 0回** - 現在の実装は完全に安全
- **平均間隔: 10秒** - 制限値（5回/秒）に対して十分な余裕
- **中央値: 5秒** - 想定通りの更新頻度

### ステータスコード分布

```
📈 ステータスコード分布:
  200: 147回 (98.0%)
  429: 3回 (2.0%)
```

HTTPレスポンスステータスコードの分布を示します。

### 残りリクエスト数統計

```
🔢 残りリクエスト数統計:
  最小: 0
  最大: 49
  平均: 25.34
  中央値: 26.00
```

レート制限バケットの残り回数の統計情報です。

### 更新間隔統計

```
⏱️ 更新間隔統計（秒）:
  最短: 0.500
  最長: 30.000
  平均: 5.230
  中央値: 5.000
```

メッセージ更新間隔の統計情報です。この情報から適切な更新頻度を判断できます。

## 推奨事項の解釈

### 警告メッセージ

- **⚠️ レート制限エラー発生**: 更新頻度を下げる必要があります
- **⚠️ 残り回数が少ない警告**: レート制限に近づいています
- **⚠️ 短い間隔での更新**: Discord APIガイドラインに違反する可能性があります

### 最適化提案

- **💡 更新頻度を上げることも可能**: レート制限に余裕があります
- **💡 更新頻度を下げることを推奨**: レート制限の使用率が高いです

### 実際のレート制限に基づく推奨事項

#### 現在の実装（安全）
- **5秒間隔**: 制限値の1/5の使用率で非常に安全
- **429エラー: 0回** - 完全に制限内

#### より頻繁な更新を考慮する場合
- **最短推奨間隔: 2秒** - 制限値の40%使用（安全マージン付き）
- **危険ゾーン: 1秒未満** - レート制限違反の高リスク

#### 動的更新の提案
```
残り時間 > 5分: 30秒間隔
残り時間 1-5分: 10秒間隔
残り時間 < 1分: 5秒間隔（現在の実装）
```

## トラブルシューティング

### ログファイルが作成されない

1. `logs` ディレクトリの作成権限を確認
2. ボットが正常に起動しているか確認
3. メッセージ編集が実際に行われているか確認

### 分析結果が空

1. ログファイルの存在確認: `ls -la logs/api_headers.jsonl`
2. ログファイルの内容確認: `head logs/api_headers.jsonl`
3. aiohttpフック確認: `aiohttp_hook: true`エントリが存在するか確認
4. メッセージ編集操作を実行してからしばらく待つ

### aiohttpフックが動作しない場合

起動ログで以下を確認:
```
INFO - aiohttp level monitoring enabled
```

このメッセージが表示されない場合:
1. discord.pyのバージョン確認
2. `src/utils/aiohttp_hook.py`の実装確認
3. 手動ログのみでも分析は可能

### 429エラーが頻発する場合

1. 現在の更新間隔を確認
2. 推奨間隔に従って`session_controller.py`の更新ロジックを調整
3. 一時的にボットを停止してレート制限のリセットを待つ

## 設定のカスタマイズ

### 環境変数による設定

以下の環境変数でログローテーションを制御可能：

```bash
# ログファイルパス（デフォルト: logs/api_headers.jsonl）
API_LOG_PATH=custom/path/api_logs.jsonl

# 最大ファイルサイズ（バイト、デフォルト: 10485760 = 10MB）
API_LOG_MAX_BYTES=20971520

# バックアップファイル数（デフォルト: 7）
API_LOG_BACKUP_COUNT=14

# デバッグモード - 全レスポンスを記録（デフォルト: false）
API_DEBUG_LOG_ALL_RESPONSES=true
```

### プログラムによる設定

`src/utils/api_monitor.py`の`DiscordAPIMonitor`クラス初期化時にパラメータを指定：

```python
monitor = DiscordAPIMonitor(
    log_file_path="custom/path/api_logs.jsonl",
    max_bytes=20 * 1024 * 1024,  # 20MB
    backup_count=14  # 14個のバックアップファイル
)
```

### 監視対象操作の追加

`api_monitor.py`の`_get_operation_type`メソッドで他のAPI操作も監視可能：

```python
def _get_operation_type(self, method: str, url: str) -> str:
    # カスタム操作タイプの追加
    if 'custom_endpoint' in url_str:
        return 'custom_operation'
```

## パフォーマンスへの影響

### 実測値
- **メッセージ編集時間**: 250-400ms（平均320ms）
- **aiohttpフックオーバーヘッド**: 測定不可能レベル（< 1ms）
- **ログファイルI/O**: 非同期実行で影響なし
- **メモリ使用量**: ヘッダ情報のみで微小（< 1KB/リクエスト）

### 監視の信頼性
- **二重ログシステム**: 手動ログとaiohttpフックの両方で冗長性確保
- **実時間精度**: ミリ秒単位での正確な実行時間測定
- **完全なレート制限可視性**: Discord APIの実際の制限値を取得

## セキュリティ考慮事項

- **APIトークン**: ログに記録されません
- **メッセージ内容**: 実際のメッセージ内容は記録されません
- **記録内容**: 以下のみ記録されます
  - HTTPメソッドとURL
  - ステータスコード
  - レート制限ヘッダ
  - 実行時間
  - タイムスタンプ
- **ファイル権限**: `logs/api_headers.jsonl`への適切なアクセス制御が推奨

## 実装の技術詳細

### フック方式の階層
1. **aiohttpセッションレベル**: discord.py内部のHTTPクライアントセッションを直接フック
2. **HTTPClient.requestレベル**: discord.pyのAPIラッパーレベルでのフック（フォールバック）
3. **アプリケーションレベル**: 手動でのメッセージ編集時間測定

### 成功要因
- aiohttpセッションの`_request`メソッドへの直接アクセス
- `ClientResponse`オブジェクトからの生ヘッダ取得
- discord.pyの内部構造を活用した低レベルフック